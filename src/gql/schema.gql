# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type ArbitragePair {
  allowTrading: Boolean
  createdAt: DateScalar
  id: Int
  kalshiMarket: KalshiMarket
  kalshiMarketTicker: String
  polymarketMarket: PolymarketMarket
  polymarketMarketID: Int
  revertPolymarket: Boolean
  updatedAt: DateScalar
}

input ArbitragePairWhere {
  id: Float
  kalshiMarketTicker: String
  polymarketMarketID: Float
}

type BidAskUpdate {
  bestAskUpdate: Order
  bestBidUpdate: Order
  marketIdentificator: String
  marketType: String
  timestamp: String
}

input BidAskUpdateWhere {
  marketIdentificator: String
  timestamp_gt: String
}

scalar BigInt

input CreateArbitragePairInput {
  kalshiMarketTicker: String!
  polymarketMarketID: Float!
  revertPolymarket: Boolean!
}

scalar DateScalar

type DeleteArbitragesReponse {
  ok: Boolean!
}

input EventWhere {
  identificator: String
}

union EventsUnion = KalshiEvent | PolymarketEvent

type KalshiEvent {
  markets: [KalshiMarket!]
  ticker: String
  title: String
}

type KalshiMarket {
  closeTime: DateScalar
  closed: Boolean
  createdTime: DateScalar
  custom: String
  event: KalshiEvent
  event_ticker: String
  marketType: String
  noSubtitle: String
  subtitle: String
  ticker: String
  title: String
  type: String
  yesSubtitle: String
}

input LoadEventInput {
  slug: String
  ticker: String
  type: String!
}

type MarketByTextResponse {
  kalshi: [KalshiMarket!]!
  polymarket: [PolymarketMarket!]!
}

union MarketUnion = KalshiMarket | PolymarketMarket

input MarketWhere {
  identificator: String
}

type Mutation {
  createArbitragePairs(pairs: [CreateArbitragePairInput!]): [ArbitragePair!]!
  deleteArbitragePairs(ids: [Int!]): DeleteArbitragesReponse!
  loadEvents(events: [LoadEventInput!]): [EventsUnion!]!
  setAllowTrading(allow: Boolean!, id: Int!): SetAllowTradingForArbPairResponse!
}

type Order {
  price: Float
  size: Int
}

type OrdersMatch {
  blockNumber: Int
  id: Int
  logIndex: Int
  makerAmountFilled: BigInt
  makerAssetId: String
  sharePrice: Int
  takerAmountFilled: BigInt
  takerAssetId: String
  takerOrderHash: String
  takerOrderMaker: String
  timestamp: Int
  transactionHash: String
}

input OrdersMatchWhere {
  blockNumber: Float
  id: Float
  makerAssetId: String
  pairAddress: String
  takerAssetId: String
  takerOrMakerAssetId: String
  timestamp: Float
  transactionHash: String
}

type PolymarketEvent {
  active: Boolean
  closed: Boolean
  description: String
  enableOrderBook: Boolean
  endDate: DateScalar
  icon: String
  id: Int
  image: String
  markets: [PolymarketMarket!]
  negRisk: Boolean
  negRiskMarketID: String
  slug: String
  startDate: DateScalar
  title: String
}

type PolymarketMarket {
  active: Boolean
  closed: Boolean
  conditionId: String
  endDate: DateScalar
  event: PolymarketEvent
  event_id: Int
  icon: String
  id: Int
  image: String
  negRisk: Boolean
  negRiskMarketID: String
  negRiskRequestID: String
  noAssetId: String
  question: String
  slug: String
  startDate: DateScalar
  type: String
  yesAssetId: String
}

type Query {
  arbitragePairs(first: Int, skip: Int, where: ArbitragePairWhere): [ArbitragePair!]!
  bestBidAskUpdates(first: Int, fromHead: Boolean, skip: Int, where: BidAskUpdateWhere): [BidAskUpdate!]!
  events(first: Int, skip: Int, where: EventWhere): [EventsUnion!]!
  marketByIdentificator(identificator: String): MarketUnion!
  markets(first: Int, skip: Int, where: MarketWhere): [MarketUnion!]!
  marketsByText(first: Int, skip: Int, text: String): MarketByTextResponse!
  ordersMatches(first: Int, fromHead: Boolean, skip: Int, where: OrdersMatchWhere): [OrdersMatch!]!
}

type SetAllowTradingForArbPairResponse {
  ok: Boolean!
}

type Subscription {
  bidAskUpdate(marketIdentificator: String!): BidAskUpdate!
}