# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type ArbitragePair {
  allowTrading: Boolean
  createdAt: DateScalar
  id: Int
  market1: MarketUnion
  market2: MarketUnion
  marketIdentificator1: String
  marketIdentificator2: String
  marketType1: String
  marketType2: String
  updatedAt: DateScalar
}

input ArbitragePairWhere {
  id: Float
  kalshiMarketTicker: String
  polymarketMarketID: Float
}

type BidAskUpdate {
  bestAskUpdate: Order
  bestBidUpdate: Order
  marketIdentificator: String
  marketType: String
  timestamp: String
}

input BidAskUpdateWhere {
  marketIdentificator: String
  timestamp_gt: String
}

scalar BigInt

input CreateArbitragePairInput {
  marketIdentificator1: String!
  marketIdentificator2: String!
  marketType1: String!
  marketType2: String!
}

scalar DateScalar

type DeleteArbitragesReponse {
  ok: Boolean!
}

input EventWhere {
  identificator: String
}

type EventsByTextResponse {
  kalshi: [KalshiEvent!]!
  polymarket: [PolymarketEvent!]!
  predictFun: [PredictFunEvent!]!
}

union EventsUnion = KalshiEvent | PolymarketEvent | PredictFunEvent

type KalshiEvent {
  markets: [KalshiMarket!]
  ticker: String
  title: String
}

type KalshiMarket {
  closeTime: DateScalar
  closed: Boolean
  createdTime: DateScalar
  custom: String
  event: KalshiEvent
  event_ticker: String
  marketType: String
  noSubtitle: String
  subtitle: String
  ticker: String
  title: String
  type: String
  yesSubtitle: String
}

type KalshiOrderFill {
  action: String
  contractsAmount: Float
  createdAt: DateScalar
  id: Int
  kalshiMarketTicker: String
  kalshiOrderID: String
  price: Float
  side: String
  timestamp: BigInt
  updatedAt: DateScalar
}

input LoadEventInput {
  slug: String
  ticker: String
  type: String!
}

type MarketByTextResponse {
  kalshi: [KalshiMarket!]!
  polymarket: [PolymarketMarket!]!
}

union MarketUnion = KalshiMarket | PolymarketMarket | PredictFunMarket

input MarketWhere {
  identificator: String
}

type Mutation {
  createArbitragePairs(pairs: [CreateArbitragePairInput!]): [ArbitragePair!]!
  deleteArbitragePairs(ids: [Int!]): DeleteArbitragesReponse!
  loadEvents(events: [LoadEventInput!]): [EventsUnion!]!
  setAllowTrading(allow: Boolean!, id: Int!): SetAllowTradingForArbPairResponse!
}

type Order {
  price: Float
  size: Int
}

union OrderFillsUnion = KalshiOrderFill | PolymarketOrderFill

type OrdersMatch {
  blockNumber: Int
  id: Int
  logIndex: Int
  makerAmountFilled: BigInt
  makerAssetId: String
  sharePrice: Int
  takerAmountFilled: BigInt
  takerAssetId: String
  takerOrderHash: String
  takerOrderMaker: String
  timestamp: Int
  transactionHash: String
}

input OrdersMatchWhere {
  blockNumber: Float
  id: Float
  makerAssetId: String
  pairAddress: String
  takerAssetId: String
  takerOrMakerAssetId: String
  timestamp: Float
  transactionHash: String
}

type PolymarketEvent {
  active: Boolean
  closed: Boolean
  description: String
  enableOrderBook: Boolean
  endDate: DateScalar
  icon: String
  id: Int
  image: String
  markets: [PolymarketMarket!]
  negRisk: Boolean
  negRiskMarketID: String
  slug: String
  startDate: DateScalar
  title: String
}

type PolymarketMarket {
  active: Boolean
  closed: Boolean
  conditionId: String
  endDate: DateScalar
  event: PolymarketEvent
  event_id: String
  icon: String
  id: String
  image: String
  negRisk: Boolean
  negRiskMarketID: String
  negRiskRequestID: String
  noAssetId: String
  question: String
  slug: String
  startDate: DateScalar
  type: String
  yesAssetId: String
}

type PolymarketOrderFill {
  action: String
  asset_id: String
  contractsAmount: Float
  createdAt: DateScalar
  id: Int
  polymarketMarketIdentificator: String
  polymarketOrderID: String
  price: Float
  timestamp: BigInt
  updatedAt: DateScalar
}

type PredictFunEvent {
  categorySlug: String
  conditionId: String
  createdAt: DateScalar
  description: String
  id: Int
  imageUrl: String
  isNegRisk: Boolean
  markets: [PredictFunMarket!]
  question: String
  status: String
  title: String
}

type PredictFunMarket {
  boostEndsAt: DateScalar
  boostStartsAt: DateScalar
  categorySlug: String
  conditionId: String
  createdAt: DateScalar
  decimalPrecision: String
  description: String
  event_id: String
  feeRateBps: String
  id: String
  imageUrl: String
  isBoosted: Boolean
  isNegRisk: Boolean
  isYieldBearing: Boolean
  marketVariant: String
  oracleQuestionId: String
  outcomes: [PredictFunOutcomeModel!]
  polymarketConditionIds: String
  question: String
  resolverAddress: String
  shareThreshold: String
  spreadThreshold: String
  status: String
  title: String
}

type PredictFunOutcomeModel {
  indexSet: Int
  name: String
  onChainId: String
  status: String
}

type Query {
  arbitragePairs(first: Int, skip: Int, where: ArbitragePairWhere): [ArbitragePair!]!
  bestBidAskUpdates(first: Int, fromHead: Boolean, skip: Int, where: BidAskUpdateWhere): [BidAskUpdate!]!
  events(first: Int, skip: Int, where: EventWhere): [EventsUnion!]!
  eventsByText(first: Int, skip: Int, text: String): EventsByTextResponse!
  marketByIdentificator(identificator: String): MarketUnion!
  markets(first: Int, skip: Int, where: MarketWhere): [MarketUnion!]!
  marketsByText(first: Int, skip: Int, text: String): MarketByTextResponse!
  orderFills(marketIdentificator: String): [OrderFillsUnion!]!
  ordersMatches(first: Int, fromHead: Boolean, skip: Int, where: OrdersMatchWhere): [OrdersMatch!]!
}

type SetAllowTradingForArbPairResponse {
  ok: Boolean!
}

type Subscription {
  bidAskUpdate(marketIdentificator: String!): BidAskUpdate!
}